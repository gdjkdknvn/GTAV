<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Urban Crime: Open World 3D</title>
    <style>
        /* --- æ ¸å¿ƒæ ·å¼ --- */
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; touch-action: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* --- UI å±‚ --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        /* HUD ä¿¡æ¯é¢æ¿ */
        .hud-top {
            position: absolute; top: 15px; left: 15px; right: 15px;
            display: flex; justify-content: space-between; pointer-events: auto;
        }
        .status-card {
            background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
            padding: 10px 15px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1);
            color: white; display: flex; flex-direction: column; gap: 5px;
            min-width: 100px;
        }
        .money { color: #2ecc71; font-weight: bold; font-size: 18px; }
        .wanted { color: #e74c3c; font-size: 16px; letter-spacing: 2px; text-shadow: 0 0 5px red; }
        .mission-hint {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(241, 196, 15, 0.8); color: black;
            padding: 8px 20px; border-radius: 20px; font-weight: bold;
            display: none; animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% {transform:translateX(-50%) scale(1);} 50% {transform:translateX(-50%) scale(1.05);} 100% {transform:translateX(-50%) scale(1);} }

        /* --- è§¦æ§åŒºåŸŸ --- */
        #touch-look-zone {
            position: absolute; top: 0; right: 0; width: 60%; height: 60%;
            z-index: 11; pointer-events: auto;
        }

        /* --- æ§åˆ¶å™¨ D-PAD --- */
        #dpad {
            position: absolute; bottom: 30px; left: 30px;
            width: 160px; height: 160px; pointer-events: auto;
        }
        .dpad-btn {
            position: absolute; background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;
            backdrop-filter: blur(4px); transition: background 0.1s;
        }
        .dpad-btn:active { background: rgba(255,255,255,0.4); }
        .dp-up { width: 50px; height: 60px; left: 55px; top: 0; }
        .dp-down { width: 50px; height: 60px; left: 55px; bottom: 0; }
        .dp-left { width: 60px; height: 50px; left: 0; top: 55px; }
        .dp-right { width: 60px; height: 50px; right: 0; top: 55px; }
        .dp-center { width: 50px; height: 50px; left: 55px; top: 55px; background: rgba(0,0,0,0.2); border-radius: 50%; }

        /* --- åŠ¨ä½œæŒ‰é’® --- */
        #actions {
            position: absolute; bottom: 30px; right: 30px;
            width: 180px; height: 180px; pointer-events: auto;
        }
        .act-btn {
            position: absolute; width: 65px; height: 65px; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: white; border: 2px solid rgba(255,255,255,0.8);
            box-shadow: 0 4px 8px rgba(0,0,0,0.5); transition: transform 0.1s;
        }
        .act-btn:active { transform: scale(0.9); opacity: 0.8; }
        
        #btn-sprint { right: 0; bottom: 0; background: rgba(46, 204, 113, 0.6); }
        #btn-interact { right: 80px; bottom: 20px; background: rgba(52, 152, 219, 0.6); display: none; }
        #btn-attack { right: 20px; bottom: 80px; background: rgba(231, 76, 60, 0.6); }

        /* --- æ‰‹æœºç³»ç»Ÿ --- */
        #phone-toggle {
            position: absolute; right: 15px; top: 120px;
            width: 50px; height: 80px; background: #222; border: 2px solid #555; border-radius: 8px;
            display: flex; align-items: center; justify-content: center; font-size: 24px;
            cursor: pointer; pointer-events: auto; color: white;
        }
        #phone-screen {
            position: absolute; right: 15px; top: 120px;
            width: 200px; height: 350px; background: #1a1a1a; border: 4px solid #333; border-radius: 15px;
            transform: scale(0); transform-origin: top right; transition: transform 0.2s;
            pointer-events: auto; padding: 10px; display: flex; flex-direction: column;
        }
        #phone-screen.open { transform: scale(1); }
        .app-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
        .app {
            background: #333; height: 60px; border-radius: 10px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; font-size: 12px; cursor: pointer;
        }
        .app:active { background: #444; }

        /* --- åŠ è½½å± --- */
        #loader {
            position: absolute; top:0; left:0; width:100%; height:100%; background: #000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 999;
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="loader">
    <h1 style="color:#3498db; text-shadow: 0 0 10px cyan;">URBAN CRIME</h1>
    <p>æ­£åœ¨ç”Ÿæˆç¨‹åºåŒ–åŸå¸‚...</p>
    <button onclick="startGame()" style="padding:15px 40px; font-size:18px; background:#2ecc71; border:none; border-radius:5px; color:white; margin-top:20px;">è¿›å…¥æ¸¸æˆ</button>
</div>

<div id="game-container"></div>

<div id="ui-layer">
    <div class="hud-top">
        <div class="status-card">
            <div class="money" id="money-txt">$0</div>
            <div style="font-size:12px; color:#aaa;">CASH</div>
        </div>
        <div class="status-card" style="align-items: flex-end;">
            <div class="wanted" id="wanted-txt"></div>
            <div style="font-size:12px; color:#aaa;">WANTED</div>
        </div>
    </div>

    <div class="mission-hint" id="mission-txt">å‰å¾€é»„è‰²å…‰æ ‡å¤„</div>

    <div id="phone-toggle" onclick="togglePhone()">ğŸ“±</div>
    <div id="phone-screen">
        <div style="text-align:center; color:white; padding-bottom:5px; border-bottom:1px solid #444;">iDroid OS</div>
        <div class="app-grid">
            <div class="app" onclick="JobSystem.start('courier')">ğŸ“¦<br>é€è´§</div>
            <div class="app" onclick="JobSystem.start('taxi')">ğŸš•<br>ä»£é©¾</div>
            <div class="app" onclick="PlayerStats.clearWanted()">ğŸš“<br>è´¿èµ‚</div>
            <div class="app" onclick="togglePhone()">âŒ<br>å…³é—­</div>
        </div>
    </div>

    <!-- è§¦æ§è§†è§’ -->
    <div id="touch-look-zone"></div>

    <!-- D-Pad -->
    <div id="dpad">
        <div class="dpad-btn dp-up" onpointerdown="Input.keys.w=true" onpointerup="Input.keys.w=false" onpointerleave="Input.keys.w=false"></div>
        <div class="dpad-btn dp-down" onpointerdown="Input.keys.s=true" onpointerup="Input.keys.s=false" onpointerleave="Input.keys.s=false"></div>
        <div class="dpad-btn dp-left" onpointerdown="Input.keys.a=true" onpointerup="Input.keys.a=false" onpointerleave="Input.keys.a=false"></div>
        <div class="dpad-btn dp-right" onpointerdown="Input.keys.d=true" onpointerup="Input.keys.d=false" onpointerleave="Input.keys.d=false"></div>
        <div class="dpad-btn dp-center"></div>
    </div>

    <!-- åŠ¨ä½œæŒ‰é’® -->
    <div id="actions">
        <div id="btn-sprint" class="act-btn" onpointerdown="Input.keys.shift=true" onpointerup="Input.keys.shift=false">ğŸƒ</div>
        <div id="btn-interact" class="act-btn" onclick="World.interact()">ğŸš—</div>
        <div id="btn-attack" class="act-btn" onpointerdown="World.playerAttack()">ğŸ‘Š</div>
    </div>
</div>

<script>
/**
 * æ¸¸æˆå¼•æ“æ ¸å¿ƒä»£ç 
 * åŒ…å«ï¼šç¨‹åºåŒ–å»ºæ¨¡ã€è½¦è¾†ç‰©ç†ã€AIäº¤é€šã€ä»»åŠ¡ç³»ç»Ÿã€è¾“å…¥ç®¡ç†
 */

// å…¨å±€å˜é‡
const Config = {
    mapSize: 200,
    blockSize: 20,
    roadWidth: 12,
    carCount: 15,
    npcCount: 10
};

let scene, camera, renderer, clock;
let player, city, jobSystem;
const entities = { cars: [], peds: [], buildings: [] };

// è¾“å…¥çŠ¶æ€
const Input = {
    keys: { w:false, a:false, s:false, d:false, shift:false },
    lookDelta: { x:0, y:0 },
    isTouch: false
};

// --- 1. åˆå§‹åŒ–ä¸å¾ªç¯ ---
function initGame() {
    // åœºæ™¯
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 20, 120);

    // ç›¸æœº
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
    camera.position.set(0, 10, 10);

    // æ¸²æŸ“å™¨
    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('game-container').appendChild(renderer.domElement);

    // ç¯å…‰
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(50, 100, 50);
    dirLight.castShadow = true;
    dirLight.shadow.camera.top = 100;
    dirLight.shadow.camera.bottom = -100;
    dirLight.shadow.camera.left = -100;
    dirLight.shadow.camera.right = 100;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    scene.add(dirLight);

    clock = new THREE.Clock();

    // ç”ŸæˆåŸå¸‚
    CityBuilder.build();
    
    // åˆ›å»ºç©å®¶
    player = new PlayerChar();

    // ç”ŸæˆAI
    Spawner.spawnTraffic();
    Spawner.spawnPeds();

    // ç³»ç»Ÿ
    JobSystem.init();

    // ç»‘å®šè¾“å…¥
    setupInputs();

    // å¼€å§‹å¾ªç¯
    animate();
}

function startGame() {
    document.getElementById('loader').style.display = 'none';
    initGame();
}

function animate() {
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.1); // é˜²æ­¢æ‰å¸§ç©¿æ¨¡

    // æ›´æ–°é€»è¾‘
    if (player) player.update(dt);
    
    // å®ä½“æ›´æ–°
    entities.cars.forEach(car => car.update(dt));
    entities.peds.forEach(ped => ped.update(dt));
    JobSystem.update(dt);

    // ç›¸æœºè·Ÿéš
    if (player) {
        const target = player.inVehicle ? player.vehicle.mesh.position : player.mesh.position;
        const offsetH = player.inVehicle ? 12 : 6;
        const offsetV = player.inVehicle ? 8 : 4;
        
        // ç®€å•çš„å¹³æ»‘è·Ÿéš
        const idealX = target.x - Math.sin(player.camRot) * offsetH;
        const idealZ = target.z - Math.cos(player.camRot) * offsetH;
        
        camera.position.x += (idealX - camera.position.x) * 0.1;
        camera.position.z += (idealZ - camera.position.z) * 0.1;
        camera.position.y += ((target.y + offsetV) - camera.position.y) * 0.1;
        
        camera.lookAt(target.x, target.y + 1, target.z);
    }

    renderer.render(scene, camera);
}

// --- 2. ç¨‹åºåŒ–å»ºæ¨¡ (Asset Generator) ---
const AssetGen = {
    // åŸºç¡€æè´¨
    mats: {
        skin: new THREE.MeshPhongMaterial({ color: 0xffdbac }),
        clothes: new THREE.MeshPhongMaterial({ color: 0x3498db }),
        pants: new THREE.MeshPhongMaterial({ color: 0x2c3e50 }),
        carBody: new THREE.MeshPhongMaterial({ color: 0xe74c3c }),
        glass: new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 100 }),
        tire: new THREE.MeshPhongMaterial({ color: 0x111111 }),
        road: new THREE.MeshPhongMaterial({ color: 0x333333 }),
        building: new THREE.MeshPhongMaterial({ color: 0x7f8c8d })
    },

    createHuman() {
        const group = new THREE.Group();
        
        // å¤´éƒ¨
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.25), this.mats.skin);
        head.position.y = 1.65;
        head.castShadow = true;
        group.add(head);

        // èº«ä½“
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.5, 0.2), this.mats.clothes);
        body.position.y = 1.25;
        body.castShadow = true;
        group.add(body);

        // è‚¢ä½“ (åˆ†ç¦»ä»¥åšåŠ¨ç”»)
        const limbGeo = new THREE.BoxGeometry(0.1, 0.5, 0.1);
        
        const legL = new THREE.Mesh(limbGeo, this.mats.pants);
        legL.position.set(-0.1, 0.75, 0);
        group.add(legL);
        
        const legR = new THREE.Mesh(limbGeo, this.mats.pants);
        legR.position.set(0.1, 0.75, 0);
        group.add(legR);
        
        const armL = new THREE.Mesh(limbGeo, this.mats.skin);
        armL.position.set(-0.25, 1.35, 0);
        group.add(armL);
        
        const armR = new THREE.Mesh(limbGeo, this.mats.skin);
        armR.position.set(0.25, 1.35, 0);
        group.add(armR);

        // ä¿å­˜å¼•ç”¨ç”¨äºåŠ¨ç”»
        group.userData = { legL, legR, armL, armR };
        return group;
    },

    createCar(color = 0xff0000, type = 'sedan') {
        const group = new THREE.Group();
        const carMat = new THREE.MeshPhongMaterial({ color: color });
        
        // åº•ç›˜
        const chassis = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.5, 4.2), carMat);
        chassis.position.y = 0.5;
        chassis.castShadow = true;
        group.add(chassis);

        // è½¦é¡¶
        const roofGeo = new THREE.BoxGeometry(1.6, 0.4, 2.2);
        const roof = new THREE.Mesh(roofGeo, this.mats.glass);
        roof.position.set(0, 1.0, -0.2);
        group.add(roof);

        // è½¦è½®
        const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 16);
        wheelGeo.rotateZ(Math.PI/2);
        
        const positions = [
            [-0.9, 0.35, 1.2], [0.9, 0.35, 1.2], 
            [-0.9, 0.35, -1.4], [0.9, 0.35, -1.4]
        ];

        positions.forEach(pos => {
            const w = new THREE.Mesh(wheelGeo, this.mats.tire);
            w.position.set(...pos);
            group.add(w);
        });

        // è½¦ç¯
        const headLight = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.1, 0.1), new THREE.MeshBasicMaterial({color:0xffffaa}));
        headLight.position.set(0, 0.5, 2.1);
        group.add(headLight);
        
        const tailLight = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.1, 0.1), new THREE.MeshBasicMaterial({color:0xff0000}));
        tailLight.position.set(0, 0.5, -2.1);
        group.add(tailLight);

        // è­¦è½¦é…ä»¶
        if (type === 'police') {
            const siren = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.3), new THREE.MeshBasicMaterial({color: 0x0000ff}));
            const siren2 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.11, 0.31), new THREE.MeshBasicMaterial({color: 0xff0000}));
            siren.position.set(0, 1.25, -0.2);
            siren2.position.set(-0.2, 1.25, -0.2);
            group.add(siren);
            group.add(siren2);
        }

        return group;
    },

    createBuilding(width, height, depth) {
        const geo = new THREE.BoxGeometry(width, height, depth);
        const mat = new THREE.MeshPhongMaterial({ color: Math.random() > 0.5 ? 0x555 : 0x777 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        // ç®€å•çš„çª—æˆ·çº¹ç†
        const winGeo = new THREE.PlaneGeometry(0.6, 1.0);
        const winMat = new THREE.MeshBasicMaterial({ color: 0xffffaa }); // äº®ç¯
        const winMatOff = new THREE.MeshBasicMaterial({ color: 0x111111 }); // ç­ç¯
        
        // ä»…åœ¨æ­£é¢æ·»åŠ ä¸€äº›çª—æˆ·ä»¥ä¼˜åŒ–æ€§èƒ½
        for (let y = 2; y < height - 2; y += 3) {
            for (let x = -width/2 + 2; x < width/2 - 2; x += 3) {
                if (Math.random() > 0.3) {
                    const w = new THREE.Mesh(winGeo, Math.random()>0.5 ? winMat : winMatOff);
                    w.position.set(x, y, depth/2 + 0.05);
                    mesh.add(w);
                }
            }
        }
        return mesh;
    }
};

// --- 3. ç©å®¶æ§åˆ¶ä¸ç‰©ç† ---
class PlayerChar {
    constructor() {
        this.mesh = AssetGen.createHuman();
        this.mesh.position.set(0, 0.5, 0);
        scene.add(this.mesh);
        
        this.camRot = Math.PI;
        this.inVehicle = false;
        this.vehicle = null;
        this.animTime = 0;
        this.hp = 100;
    }

    update(dt) {
        if (this.inVehicle) {
            this.mesh.visible = false;
            this.updateDriving(dt);
        } else {
            this.mesh.visible = true;
            this.updateWalking(dt);
        }
        
        // æ—‹è½¬ç›¸æœº
        if (Input.lookDelta.x !== 0) {
            this.camRot -= Input.lookDelta.x * 2.0;
            Input.lookDelta.x = 0; // Reset after consume
        }
    }

    updateWalking(dt) {
        let speed = 0;
        const runMult = Input.keys.shift ? 2.0 : 1.0;
        const moveSpeed = 5.0 * runMult;

        // åŸºäºç›¸æœºçš„ç§»åŠ¨æ–¹å‘
        const dir = new THREE.Vector3();
        const fwd = new THREE.Vector3(Math.sin(this.camRot), 0, Math.cos(this.camRot));
        const right = new THREE.Vector3(Math.sin(this.camRot - Math.PI/2), 0, Math.cos(this.camRot - Math.PI/2));

        if (Input.keys.w) dir.add(fwd);
        if (Input.keys.s) dir.sub(fwd);
        if (Input.keys.a) dir.sub(right);
        if (Input.keys.d) dir.add(right);

        if (dir.lengthSq() > 0) {
            dir.normalize();
            speed = moveSpeed;
            
            // è§’è‰²æœå‘æ’å€¼
            const targetRot = Math.atan2(dir.x, dir.z);
            let rotDiff = targetRot - this.mesh.rotation.y;
            // è§’åº¦æ ‡å‡†åŒ–
            while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
            while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
            this.mesh.rotation.y += rotDiff * 10 * dt;

            // ç§»åŠ¨å¹¶æ£€æµ‹ç¢°æ’
            const moveVec = dir.multiplyScalar(speed * dt);
            const nextPos = this.mesh.position.clone().add(moveVec);
            
            if (!CityBuilder.checkCollision(nextPos)) {
                this.mesh.position.copy(nextPos);
            }

            // åŠ¨ç”»
            this.animTime += dt * 10 * runMult;
            this.animateLegs(Math.sin(this.animTime));
        } else {
            this.animateLegs(0); // Idle
        }

        // æ£€æµ‹äº¤äº’
        World.checkInteraction(this.mesh.position);
    }

    updateDriving(dt) {
        if (!this.vehicle) return;
        
        // ç»§æ‰¿è½¦è¾†çš„æ§åˆ¶é€»è¾‘ï¼Œè¿™é‡Œåªæ›´æ–°ç©å®¶ä½ç½®è·Ÿéšè½¦
        this.mesh.position.copy(this.vehicle.mesh.position);
        this.camRot = this.vehicle.mesh.rotation.y + Math.PI; // ç›¸æœºè‡ªåŠ¨å›æ­£
    }

    animateLegs(val) {
        const parts = this.mesh.userData;
        parts.legL.rotation.x = val;
        parts.legR.rotation.x = -val;
        parts.armL.rotation.x = -val;
        parts.armR.rotation.x = val;
    }
}

// --- 4. è½¦è¾†ç³»ç»Ÿ (å¤æ‚ç‰©ç†) ---
class Vehicle {
    constructor(x, z, type='civilian') {
        const color = type==='police' ? 0xffffff : Math.random() * 0xffffff;
        this.mesh = AssetGen.createCar(color, type);
        this.mesh.position.set(x, 0.5, z);
        this.mesh.rotation.y = Math.random() * Math.PI * 2;
        scene.add(this.mesh);

        this.type = type;
        this.speed = 0;
        this.acceleration = 0;
        this.steering = 0;
        this.driver = null; // 'player', 'ai', or null
        
        // ç‰©ç†å‚æ•°
        this.maxSpeed = 0.8;
        this.enginePower = 1.2;
        this.friction = 0.96;
        this.turnSpeed = 2.0;
    }

    update(dt) {
        if (this.driver === 'player') {
            this.handleInput(dt);
        } else if (this.driver === 'ai') {
            this.handleAI(dt);
        } else {
            // ç©ºè½¦æ‘©æ“¦åŠ›
            this.speed *= 0.95;
        }

        // åº”ç”¨é€Ÿåº¦
        this.speed *= this.friction;
        
        // è½¬å‘ (åªæœ‰ç§»åŠ¨æ—¶æ‰èƒ½è½¬å‘)
        if (Math.abs(this.speed) > 0.01) {
            this.mesh.rotation.y += this.steering * this.turnSpeed * dt * Math.sign(this.speed);
        }

        // ä½ç½®æ›´æ–°
        const vx = Math.sin(this.mesh.rotation.y) * this.speed;
        const vz = Math.cos(this.mesh.rotation.y) * this.speed;
        
        const nextPos = this.mesh.position.clone();
        nextPos.x += vx;
        nextPos.z += vz;

        // ç¢°æ’æ£€æµ‹
        if (!CityBuilder.checkCollision(nextPos)) {
            this.mesh.position.copy(nextPos);
        } else {
            this.speed *= -0.5; // æ’å‡»åå¼¹
        }
        
        // ç®€å•çš„è¾¹ç•Œå¾ªç¯
        const limit = Config.mapSize / 2;
        if (Math.abs(this.mesh.position.x) > limit) this.mesh.position.x *= -0.99;
        if (Math.abs(this.mesh.position.z) > limit) this.mesh.position.z *= -0.99;
    }

    handleInput(dt) {
        // åŠ é€Ÿ/å€’è½¦
        if (Input.keys.w) this.speed += this.enginePower * dt;
        if (Input.keys.s) this.speed -= (this.enginePower * 0.8) * dt;
        
        // è½¬å‘
        this.steering = 0;
        if (Input.keys.a) this.steering = 1;
        if (Input.keys.d) this.steering = -1;
    }

    handleAI(dt) {
        // ç®€å•çš„è‡ªåŠ¨é©¾é©¶ï¼šå‰è¿›ï¼Œé‡åˆ°éšœç¢ç‰©è½¬å‘
        const sensorDist = 8;
        const fwd = new THREE.Vector3(Math.sin(this.mesh.rotation.y), 0, Math.cos(this.mesh.rotation.y));
        const sensorPos = this.mesh.position.clone().add(fwd.multiplyScalar(sensorDist));
        
        let blocked = CityBuilder.checkCollision(sensorPos);
        
        if (!blocked) {
            // æ£€æŸ¥å‰æ–¹æ˜¯å¦æœ‰å…¶ä»–è½¦
            for(let other of entities.cars) {
                if (other !== this && this.mesh.position.distanceTo(other.mesh.position) < 8) {
                     // ç®€å•é¿è®©
                     blocked = true; 
                     break;
                }
            }
        }

        if (blocked) {
            this.speed *= 0.9; // å‡é€Ÿ
            this.steering = 1; // å³è½¬é¿è®©
        } else {
            if (this.speed < 0.4) this.speed += this.enginePower * dt * 0.5;
            this.steering = 0;
            // å¶å°”éšæœºè½¬å‘
            if (Math.random() < 0.01) this.steering = (Math.random()-0.5)*2;
        }
    }
}

// --- 5. åŸå¸‚æ„å»ºå™¨ (World Generation) ---
const CityBuilder = {
    grid: [],

    build() {
        // åœ°é¢
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(Config.mapSize + 50, Config.mapSize + 50),
            new THREE.MeshPhongMaterial({ color: 0x222 })
        );
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        scene.add(ground);

        // ç®€å•çš„ç½‘æ ¼åœ°å›¾ç®—æ³•
        const count = Config.mapSize / Config.blockSize;
        const offset = Config.mapSize / 2;

        for (let x = 0; x < count; x++) {
            this.grid[x] = [];
            for (let y = 0; y < count; y++) {
                // ç•™å‡ºé“è·¯: æ¯3ä¸ªæ ¼å­æ˜¯è·¯
                const isRoad = (x % 3 === 0 || y % 3 === 0);
                
                const px = (x * Config.blockSize) - offset;
                const pz = (y * Config.blockSize) - offset;

                if (!isRoad) {
                    // å»ºæ¥¼
                    const h = 10 + Math.random() * 30;
                    const building = AssetGen.createBuilding(Config.blockSize - 4, h, Config.blockSize - 4);
                    building.position.set(px, h/2, pz);
                    scene.add(building);
                    
                    // ç¢°æ’ä½“æ•°æ®
                    entities.buildings.push({
                        x: px, z: pz, 
                        w: Config.blockSize - 4, 
                        d: Config.blockSize - 4
                    });
                } else {
                    // è£…é¥°ï¼šè·¯ç¯/æ ‘
                    if (Math.random() < 0.3 && x%3===0 && y%3!==0) { // è·¯è¾¹
                        const tree = new THREE.Mesh(new THREE.ConeGeometry(1, 4, 8), new THREE.MeshLambertMaterial({color:0x2ecc71}));
                        tree.position.set(px + 8, 2, pz);
                        scene.add(tree);
                    }
                }
                
                this.grid[x][y] = isRoad ? 0 : 1; // 0è·¯ 1å¢™
            }
        }
    },

    checkCollision(pos) {
        // åŸºäºAABBçš„å»ºç­‘ç¢°æ’æ£€æµ‹
        for (let b of entities.buildings) {
            if (Math.abs(pos.x - b.x) < b.w/2 + 0.5 && 
                Math.abs(pos.z - b.z) < b.d/2 + 0.5) {
                return true;
            }
        }
        // è¾¹ç•Œ
        const limit = Config.mapSize / 2;
        if (Math.abs(pos.x) > limit || Math.abs(pos.z) > limit) return true;
        return false;
    }
};

// --- 6. ç©æ³•ç®¡ç† (Interaction & Spawner) ---
const World = {
    nearestCar: null,

    checkInteraction(playerPos) {
        let minDist = 5;
        this.nearestCar = null;
        
        entities.cars.forEach(car => {
            const d = playerPos.distanceTo(car.mesh.position);
            if (d < minDist) {
                minDist = d;
                this.nearestCar = car;
            }
        });

        const btn = document.getElementById('btn-interact');
        if (player.inVehicle) {
            btn.style.display = 'flex';
            btn.innerText = 'ğŸƒ'; // ä¸‹è½¦
        } else if (this.nearestCar) {
            btn.style.display = 'flex';
            btn.innerText = 'ğŸš—'; // ä¸Šè½¦
        } else {
            btn.style.display = 'none';
        }
    },

    interact() {
        if (player.inVehicle) {
            // ä¸‹è½¦
            player.inVehicle = false;
            player.vehicle.driver = null; // å˜æˆç©ºè½¦
            player.mesh.position.x += 2.5; // ç§»åˆ°è½¦æ—
            player.vehicle = null;
        } else if (this.nearestCar) {
            // ä¸Šè½¦
            player.inVehicle = true;
            player.vehicle = this.nearestCar;
            player.vehicle.driver = 'player'; // ç©å®¶æ¥ç®¡
            
            // å·è½¦å¢åŠ é€šç¼‰
            if (player.vehicle.type === 'police') PlayerStats.addWanted(2);
            else if (Math.random() > 0.7) PlayerStats.addWanted(1);
        }
    },
    
    playerAttack() {
        if (player.inVehicle) return; // å–‡å­?
        
        // ç®€å•çš„æ”»å‡»åŠ¨ä½œ
        const armR = player.mesh.userData.armR;
        armR.rotation.x = -1.5;
        setTimeout(() => armR.rotation.x = 0, 200);

        // åˆ¤å®š
        let hit = false;
        entities.peds.forEach(ped => {
            if (ped.mesh.position.distanceTo(player.mesh.position) < 2) {
                ped.die();
                hit = true;
                PlayerStats.addMoney(Math.floor(Math.random()*50) + 10);
                PlayerStats.addWanted(1);
            }
        });
    }
};

const Spawner = {
    spawnTraffic() {
        for(let i=0; i<Config.carCount; i++) {
            const pos = this.getRandomRoadPos();
            const car = new Vehicle(pos.x, pos.z, Math.random()<0.1 ? 'police' : 'civilian');
            car.driver = 'ai';
            entities.cars.push(car);
        }
    },
    
    spawnPeds() {
        for(let i=0; i<Config.npcCount; i++) {
            const pos = this.getRandomRoadPos();
            const ped = new Pedestrian(pos.x, pos.z);
            entities.peds.push(ped);
        }
    },

    getRandomRoadPos() {
        let x, z;
        let tries = 0;
        do {
            x = (Math.random() - 0.5) * Config.mapSize;
            z = (Math.random() - 0.5) * Config.mapSize;
            tries++;
        } while(CityBuilder.checkCollision({x, z}) && tries < 100);
        return {x, z};
    }
};

// --- 7. NPCé€»è¾‘ ---
class Pedestrian {
    constructor(x, z) {
        this.mesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.5, 0.3), new THREE.MeshLambertMaterial({color: Math.random()*0xffffff}));
        this.mesh.position.set(x, 0.75, z);
        scene.add(this.mesh);
        this.target = null;
        this.dead = false;
    }
    
    update(dt) {
        if (this.dead) return;
        
        if (!this.target || Math.random() < 0.01) {
            const dest = Spawner.getRandomRoadPos();
            this.target = new THREE.Vector3(dest.x, 0.75, dest.z);
        }
        
        const dir = new THREE.Vector3().subVectors(this.target, this.mesh.position);
        if (dir.lengthSq() > 0.1) {
            dir.normalize();
            const nextPos = this.mesh.position.clone().add(dir.multiplyScalar(2 * dt));
            if (!CityBuilder.checkCollision(nextPos)) {
                this.mesh.position.copy(nextPos);
                this.mesh.lookAt(this.target);
            } else {
                this.target = null; // æ’å¢™æ¢ç›®æ ‡
            }
        }
    }

    die() {
        this.dead = true;
        this.mesh.rotation.x = Math.PI/2;
        this.mesh.position.y = 0.2;
        this.mesh.material.color.setHex(0xff0000);
    }
}

// --- 8. ä»»åŠ¡ä¸çŠ¶æ€ç³»ç»Ÿ ---
const PlayerStats = {
    money: 0,
    wanted: 0,
    addMoney(n) { this.money += n; document.getElementById('money-txt').innerText = '$'+this.money; },
    addWanted(n) { 
        this.wanted = Math.min(5, this.wanted + n);
        let s = ""; for(let i=0; i<this.wanted; i++) s += "â˜…";
        document.getElementById('wanted-txt').innerText = s;
        // ç”Ÿæˆè­¦å¯Ÿè¿½æ•
        if (this.wanted > 2 && Math.random() > 0.9) {
            const pos = Spawner.getRandomRoadPos();
            const cop = new Vehicle(pos.x, pos.z, 'police');
            cop.driver = 'ai'; // ç®€åŒ–ï¼šåº”è¯¥è®¾ä¸ºè¿½æ•æ¨¡å¼
            entities.cars.push(cop);
        }
    },
    clearWanted() {
        if (this.money >= 500) {
            this.money -= 500;
            this.wanted = 0;
            this.addMoney(0); // refresh UI
            this.addWanted(0);
        }
    }
};

const JobSystem = {
    active: false,
    marker: null,
    
    init() {
        const geo = new THREE.CylinderGeometry(2, 2, 20, 32);
        const mat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 });
        this.marker = new THREE.Mesh(geo, mat);
        this.marker.visible = false;
        scene.add(this.marker);
    },
    
    start(type) {
        if (this.active) return;
        this.active = true;
        const pos = Spawner.getRandomRoadPos();
        this.marker.position.set(pos.x, 10, pos.z);
        this.marker.visible = true;
        
        document.getElementById('mission-txt').style.display = 'block';
        togglePhone(); // å…³æ‰‹æœº
    },
    
    update(dt) {
        if (!this.active) return;
        this.marker.rotation.y += dt;
        
        const pPos = player.inVehicle ? player.vehicle.mesh.position : player.mesh.position;
        if (pPos.distanceTo(new THREE.Vector3(this.marker.position.x, 0.5, this.marker.position.z)) < 5) {
            // å®Œæˆä»»åŠ¡
            this.complete();
        }
    },
    
    complete() {
        this.active = false;
        this.marker.visible = false;
        document.getElementById('mission-txt').style.display = 'none';
        PlayerStats.addMoney(1000);
        alert("ä»»åŠ¡å®Œæˆï¼è·å¾— $1000");
    }
};

// --- 9. è¾“å…¥äº‹ä»¶ç»‘å®š ---
function setupInputs() {
    // è§¦æ§è§†è§’
    const zone = document.getElementById('touch-look-zone');
    let lastX = 0;
    zone.addEventListener('touchstart', e => { Input.isTouch = true; lastX = e.touches[0].clientX; });
    zone.addEventListener('touchmove', e => {
        e.preventDefault();
        const delta = e.touches[0].clientX - lastX;
        Input.lookDelta.x = delta * 0.005;
        lastX = e.touches[0].clientX;
    });
    zone.addEventListener('touchend', () => { Input.lookDelta.x = 0; });

    // é”®ç›˜æ”¯æŒ (PCè°ƒè¯•)
    window.addEventListener('keydown', e => {
        if(e.key.toLowerCase() in Input.keys) Input.keys[e.key.toLowerCase()] = true;
        if(e.key === 'Shift') Input.keys.shift = true;
        if(e.key === 'f') World.interact();
        if(e.key === ' ') World.playerAttack();
    });
    window.addEventListener('keyup', e => {
        if(e.key.toLowerCase() in Input.keys) Input.keys[e.key.toLowerCase()] = false;
        if(e.key === 'Shift') Input.keys.shift = false;
    });
}

function togglePhone() {
    document.getElementById('phone-screen').classList.toggle('open');
}

// çª—å£è°ƒæ•´
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
